// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Plc/Gds/ISubscriptionService.proto
// </auto-generated>
// Original file comments:
// /////////////////////////////////////////////////////////////////////////////
//
//  Copyright PHOENIX CONTACT Electronics GmbH
//
// /////////////////////////////////////////////////////////////////////////////
//
#pragma warning disable 0414, 1591, 8981, 0612
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Arp.Plc.Gds.Services.Grpc {
  public static partial class ISubscriptionService
  {
    static readonly string __ServiceName = "Arp.Plc.Gds.Services.Grpc.ISubscriptionService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateSubscriptionRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateSubscriptionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateRecordingSubscriptionRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateRecordingSubscriptionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariableRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariableResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariablesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariablesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceRemoveVariableRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceRemoveVariableResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceSubscribeRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceSubscribeResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceResubscribeRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceResubscribeResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceUnsubscribeRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceUnsubscribeResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceDeleteSubscriptionRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceDeleteSubscriptionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetVariableInfosRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetVariableInfosResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetTimeStampedVariableInfosRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetTimeStampedVariableInfosResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetRecordInfosRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetRecordInfosResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadValuesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadValuesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadTimeStampedValuesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadTimeStampedValuesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadRecordsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse> __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadRecordsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse> __Method_CreateSubscription = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateSubscription",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateSubscriptionRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateSubscriptionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse> __Method_CreateRecordingSubscription = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateRecordingSubscription",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateRecordingSubscriptionRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceCreateRecordingSubscriptionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse> __Method_AddVariable = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AddVariable",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariableRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariableResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse> __Method_AddVariables = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AddVariables",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariablesRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceAddVariablesResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse> __Method_RemoveVariable = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RemoveVariable",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceRemoveVariableRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceRemoveVariableResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse> __Method_Subscribe = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Subscribe",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceSubscribeRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceSubscribeResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse> __Method_Resubscribe = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Resubscribe",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceResubscribeRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceResubscribeResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse> __Method_Unsubscribe = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Unsubscribe",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceUnsubscribeRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceUnsubscribeResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse> __Method_DeleteSubscription = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteSubscription",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceDeleteSubscriptionRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceDeleteSubscriptionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse> __Method_GetVariableInfos = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetVariableInfos",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetVariableInfosRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetVariableInfosResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse> __Method_GetTimeStampedVariableInfos = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetTimeStampedVariableInfos",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetTimeStampedVariableInfosRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetTimeStampedVariableInfosResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse> __Method_GetRecordInfos = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetRecordInfos",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetRecordInfosRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceGetRecordInfosResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse> __Method_ReadValues = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ReadValues",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadValuesRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadValuesResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse> __Method_ReadTimeStampedValues = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ReadTimeStampedValues",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadTimeStampedValuesRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadTimeStampedValuesResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse> __Method_ReadRecords = new grpc::Method<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ReadRecords",
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadRecordsRequest,
        __Marshaller_Arp_Plc_Gds_Services_Grpc_ISubscriptionServiceReadRecordsResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of ISubscriptionService</summary>
    [grpc::BindServiceMethod(typeof(ISubscriptionService), "BindService")]
    public abstract partial class ISubscriptionServiceBase
    {
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of the given &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This method allows other components, also from remote targets,
      ///&#x2F; to create a subscription which is able to subscribe each PLC variable.
      ///&#x2F; On success it returns a unique &lt;c>SubscriptionId&lt;/c> which is
      ///&#x2F; created internally. The &lt;c>SubscriptionId&lt;/c> has to be exposed to the SDK
      ///&#x2F; user, due to the usage on remote targets. The &lt;c>SubscriptionId&lt;/c> is
      ///&#x2F; the reference to a created subscription at the PLC target and is needed in
      ///&#x2F; each subscription method exclude this and &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each subscription contains at least one buffer which kind depends on the
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      ///&#x2F; tasks which contains the added variables. The buffer are initialized with a
      ///&#x2F; &lt;see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      ///&#x2F; Apart from &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      ///&#x2F; the task. How often the task stores the data to the buffer depends on the task
      ///&#x2F; cycle time and the configured subscription sample interval.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      ///&#x2F; created. Each kind has its own benefits and differs in consistence, performance and
      ///&#x2F; memory usage. The available kinds are listed below:
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;list type="table">
      ///&#x2F; &lt;listheader>
      ///&#x2F; &lt;term>kind&lt;/term>
      ///&#x2F; &lt;description>description&lt;/description>
      ///&#x2F; &lt;/listheader>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; The subscription itself triggers the copy process and will read the data
      ///&#x2F; directly from the source. This could be the fastest way and with no
      ///&#x2F; influence to the real time, to get the current data, but
      ///&#x2F; the task consistency is not guaranteed.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Asynchronous data collection for non critical data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>DoubleBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has low
      ///&#x2F; influence to the real time and is low in memory usage.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Standard way to collect the variable data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>QuadBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has the
      ///&#x2F; fastest access to the current written data, but uses the fourfold memory.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in high speed tasks and for which
      ///&#x2F; it is necessary to guarantee the fastest access to the current written data.
      ///&#x2F; Note that in most cases the &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      ///&#x2F; sufficient.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>RingBuffer&lt;/c> which is able to store
      ///&#x2F; more than one record of data. This kind is task consistent, has low
      ///&#x2F; influence to the real time, but needs, dependent to the ring capacity, a lot
      ///&#x2F; of memory. By default the ring capacity is &lt;c>10&lt;/c>, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      ///&#x2F; witch a self defined size.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in faster tasks than the consumer does
      ///&#x2F; and for which it is necessary to guarantee that every data record will be stored,
      ///&#x2F; without a single gap.
      ///&#x2F; Note that this kind uses a lot of memory!
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;/list>
      ///&#x2F; &lt;para>
      ///&#x2F; After the subscription is created successfully, variables could be added with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      ///&#x2F; with the &lt;c>SubscriptionId&lt;/c> just returned in this method.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="kind">
      ///&#x2F; The kind of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;para>&lt;/para>&lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse> CreateSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; This method creates a subscription of the kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; Compared to the method &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      ///&#x2F; configure the capacity of the internal used ring buffer.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="recordCount">
      ///&#x2F; The maximum number of storable records.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse> CreateRecordingSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting the given
      ///&#x2F; variable name
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The added variable is stored in a internal container and will be
      ///&#x2F; subscribed after calling &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      ///&#x2F; the subscription has already been subscribed, it is necessary to
      ///&#x2F; call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      ///&#x2F; added variable finally.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; If the same full variable name is added multiple times, the old variable will be
      ///&#x2F; overridden. In case, a variable name is invalid or doesn't exists
      ///&#x2F; a specific error code will be returned &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; on success the code &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; of the added variable will be returned. A variable which doesn't returned with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      ///&#x2F; and won't be subscribed.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A single array element can added with its index in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[index]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; If an array variable is added without a variable specification,
      ///&#x2F; the entire array will be added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; An alternative way to insert variables to the subscription is by using
      ///&#x2F; the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variable is add to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse> AddVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting a range of new variables.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Allows to add a range of variables to the subscription. The returned array of type &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variables are added to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableNames">
      ///&#x2F; An array of full variable names.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns a vector of &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />, &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; on success, in the same order as the variables were added.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse> AddVariables(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Removes the variable with the specific variable name from the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Removes the variable that compare equal to the given variable name, from the
      ///&#x2F; internal variable list. If the subscription has already been subscribed,
      ///&#x2F; it is necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      ///&#x2F; remove the given variable from the internal created buffer.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable to be removed from the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse> RemoveVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Subscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; All previously added variables including in the given subscription will be subscribed. Internally
      ///&#x2F; the variables are separated in the respective tasks, a buffer for each task will be created and
      ///&#x2F; connected to the task executed event. At this point the task will copy the selected variable data
      ///&#x2F; into the task buffer (excluded subscriptions from kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      ///&#x2F; How often the task stores the data to the buffer depends on the task cycle time and the
      ///&#x2F; configured subscription sample rate.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Calling this method on a already subscribed subscription has no effect, even if new
      ///&#x2F; variables have been added or removed. To make variable modification effective, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      ///&#x2F; &lt;c>Unsubscribed&lt;/c>, because &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      ///&#x2F; connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      ///&#x2F; Compare to the first and initial call of this method, this call cost more less time because
      ///&#x2F; the buffer are already created. This also means that variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      ///&#x2F; it is also necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A subscribed subscription can operates in different sample rates (excluded subscriptions from
      ///&#x2F; kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      ///&#x2F; First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      ///&#x2F; the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      ///&#x2F; task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      ///&#x2F; Thats the case if the given sample rate is set to zero,
      ///&#x2F; which means the subscription operates in &lt;c>'real-time'&lt;/c>, the same sample rate the task is operating in.
      ///&#x2F; This is also the fastest possible rate for a subscription.
      ///&#x2F; Note that it's possible that one subscription could contain variables from different tasks, which has the
      ///&#x2F; consequence that the subscription operates in different rates!
      ///&#x2F; If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      ///&#x2F; no matter from which task this variable comes.
      ///&#x2F; Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      ///&#x2F; the given rate will rounded down. E.g.:
      ///&#x2F;
      ///&#x2F; &lt;code>
      ///&#x2F; Task A cycle rate = 10ms
      ///&#x2F; Task B cycle rate = 8ms
      ///&#x2F;
      ///&#x2F; Subscription given rate = 50ms
      ///&#x2F;
      ///&#x2F; Subscription rate for task A = 50ms
      ///&#x2F; Subscription rate for task B = 48ms
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      ///&#x2F; the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      ///&#x2F; But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      ///&#x2F; the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      ///&#x2F; downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      ///&#x2F; or an multiple of them.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse> Subscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Resubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Resubscribes the subscription, which will trigger a completely rebuild process of
      ///&#x2F; the whole subscription, including previously done variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; It destroys the internal buffer and subscribes the subscription again
      ///&#x2F; (for further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      ///&#x2F; Note that the subscription is not able to collect data from the variables, while the
      ///&#x2F; resubscribe process is in progress.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse> Resubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Unsubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Unsubscribes the subscription from all task executed events. The subscription
      ///&#x2F; data are still exist and could be get by the respective read-methods. To
      ///&#x2F; subscribe the subscription again, call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse> Unsubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Deletes the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Deletes the subscription with the given id. After that the id is no longer valid and all data,
      ///&#x2F; containing in the subscription will be removed.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse> DeleteSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The subscription service provides several read functions
      ///&#x2F; (&lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      ///&#x2F; return the plain values without any information of type and order.
      ///&#x2F; To assign this plain values to the added variables, this function returns
      ///&#x2F; the currently subscribed variable information in a array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      ///&#x2F; This order and type information wont change, till
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      ///&#x2F; Note that this order does not have to be the same order like the
      ///&#x2F; variables has been added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      ///&#x2F; The provided information contains only information of the added and
      ///&#x2F; currently subscribed variables. It doesn't contain information
      ///&#x2F; of timestamps. Timestamps could be read by the function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      ///&#x2F; information with &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      ///&#x2F; timestamp information.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse> GetVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information including information
      ///&#x2F; of timestamps of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables and additionally information about the
      ///&#x2F; timestamps. Note that a subscription could contain multiple
      ///&#x2F; timestamps, related on the number of used tasks from which the
      ///&#x2F; added variables are from. The timestamp is always the first value
      ///&#x2F; followed by all to the task related variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse> GetTimeStampedVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information as a record of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables, its task relation and additionally
      ///&#x2F; information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The information are provided in an array of array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      ///&#x2F; number of different tasks and the second contains the related variable
      ///&#x2F; information which are related to the variables of this task and
      ///&#x2F; additionally information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[][]
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note: This function is currently not supported in C#!.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="recordInfos">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse> GetRecordInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables. The data values are returned
      ///&#x2F; in a static order and doesn't contain any type information. To
      ///&#x2F; figure out which value belongs to the added variable, it is necessary
      ///&#x2F; to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note that this values doesn't contain timestamps! If the timestamp is
      ///&#x2F; needed use the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      ///&#x2F; instead.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values of the given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse> ReadValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; timestamp task A
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp task B
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values including the timestamps of the
      ///&#x2F; given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse> ReadTimeStampedValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id
      ///&#x2F; separated in task records.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps separated
      ///&#x2F; in task records.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The number of returned value records depends on the count of tasks,
      ///&#x2F; the number of sampled data and the number of the given
      ///&#x2F; &lt;paramref name="count" /> parameter.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The structure how the values are returned is strictly defined:
      ///&#x2F; The first array (records) contains n arrays (task records) and where
      ///&#x2F; n depends on the number of tasks.
      ///&#x2F; The array from the second dimension (task records) contains n arrays
      ///&#x2F; (record), where n depends on the number of collected data, one data
      ///&#x2F; record per task cycle.
      ///&#x2F; The array from the third dimension (record) contains the plain
      ///&#x2F; values, starting with the timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; task A sampled 2 cycles
      ///&#x2F; task B sampled 1 cycles
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[] (records)
      ///&#x2F; object[] (task A records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (record cycle 2)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (task B records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="count">
      ///&#x2F; Number of maximum records to be copied per task. If set to zero, all available records
      ///&#x2F; will be copied.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="records">
      ///&#x2F; Array for the subscribed data records including timestamps.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse> ReadRecords(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for ISubscriptionService</summary>
    public partial class ISubscriptionServiceClient : grpc::ClientBase<ISubscriptionServiceClient>
    {
      /// <summary>Creates a new client for ISubscriptionService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public ISubscriptionServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for ISubscriptionService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public ISubscriptionServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected ISubscriptionServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected ISubscriptionServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of the given &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This method allows other components, also from remote targets,
      ///&#x2F; to create a subscription which is able to subscribe each PLC variable.
      ///&#x2F; On success it returns a unique &lt;c>SubscriptionId&lt;/c> which is
      ///&#x2F; created internally. The &lt;c>SubscriptionId&lt;/c> has to be exposed to the SDK
      ///&#x2F; user, due to the usage on remote targets. The &lt;c>SubscriptionId&lt;/c> is
      ///&#x2F; the reference to a created subscription at the PLC target and is needed in
      ///&#x2F; each subscription method exclude this and &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each subscription contains at least one buffer which kind depends on the
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      ///&#x2F; tasks which contains the added variables. The buffer are initialized with a
      ///&#x2F; &lt;see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      ///&#x2F; Apart from &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      ///&#x2F; the task. How often the task stores the data to the buffer depends on the task
      ///&#x2F; cycle time and the configured subscription sample interval.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      ///&#x2F; created. Each kind has its own benefits and differs in consistence, performance and
      ///&#x2F; memory usage. The available kinds are listed below:
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;list type="table">
      ///&#x2F; &lt;listheader>
      ///&#x2F; &lt;term>kind&lt;/term>
      ///&#x2F; &lt;description>description&lt;/description>
      ///&#x2F; &lt;/listheader>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; The subscription itself triggers the copy process and will read the data
      ///&#x2F; directly from the source. This could be the fastest way and with no
      ///&#x2F; influence to the real time, to get the current data, but
      ///&#x2F; the task consistency is not guaranteed.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Asynchronous data collection for non critical data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>DoubleBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has low
      ///&#x2F; influence to the real time and is low in memory usage.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Standard way to collect the variable data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>QuadBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has the
      ///&#x2F; fastest access to the current written data, but uses the fourfold memory.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in high speed tasks and for which
      ///&#x2F; it is necessary to guarantee the fastest access to the current written data.
      ///&#x2F; Note that in most cases the &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      ///&#x2F; sufficient.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>RingBuffer&lt;/c> which is able to store
      ///&#x2F; more than one record of data. This kind is task consistent, has low
      ///&#x2F; influence to the real time, but needs, dependent to the ring capacity, a lot
      ///&#x2F; of memory. By default the ring capacity is &lt;c>10&lt;/c>, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      ///&#x2F; witch a self defined size.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in faster tasks than the consumer does
      ///&#x2F; and for which it is necessary to guarantee that every data record will be stored,
      ///&#x2F; without a single gap.
      ///&#x2F; Note that this kind uses a lot of memory!
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;/list>
      ///&#x2F; &lt;para>
      ///&#x2F; After the subscription is created successfully, variables could be added with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      ///&#x2F; with the &lt;c>SubscriptionId&lt;/c> just returned in this method.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="kind">
      ///&#x2F; The kind of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;para>&lt;/para>&lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse CreateSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateSubscription(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of the given &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This method allows other components, also from remote targets,
      ///&#x2F; to create a subscription which is able to subscribe each PLC variable.
      ///&#x2F; On success it returns a unique &lt;c>SubscriptionId&lt;/c> which is
      ///&#x2F; created internally. The &lt;c>SubscriptionId&lt;/c> has to be exposed to the SDK
      ///&#x2F; user, due to the usage on remote targets. The &lt;c>SubscriptionId&lt;/c> is
      ///&#x2F; the reference to a created subscription at the PLC target and is needed in
      ///&#x2F; each subscription method exclude this and &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each subscription contains at least one buffer which kind depends on the
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      ///&#x2F; tasks which contains the added variables. The buffer are initialized with a
      ///&#x2F; &lt;see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      ///&#x2F; Apart from &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      ///&#x2F; the task. How often the task stores the data to the buffer depends on the task
      ///&#x2F; cycle time and the configured subscription sample interval.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      ///&#x2F; created. Each kind has its own benefits and differs in consistence, performance and
      ///&#x2F; memory usage. The available kinds are listed below:
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;list type="table">
      ///&#x2F; &lt;listheader>
      ///&#x2F; &lt;term>kind&lt;/term>
      ///&#x2F; &lt;description>description&lt;/description>
      ///&#x2F; &lt;/listheader>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; The subscription itself triggers the copy process and will read the data
      ///&#x2F; directly from the source. This could be the fastest way and with no
      ///&#x2F; influence to the real time, to get the current data, but
      ///&#x2F; the task consistency is not guaranteed.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Asynchronous data collection for non critical data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>DoubleBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has low
      ///&#x2F; influence to the real time and is low in memory usage.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Standard way to collect the variable data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>QuadBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has the
      ///&#x2F; fastest access to the current written data, but uses the fourfold memory.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in high speed tasks and for which
      ///&#x2F; it is necessary to guarantee the fastest access to the current written data.
      ///&#x2F; Note that in most cases the &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      ///&#x2F; sufficient.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>RingBuffer&lt;/c> which is able to store
      ///&#x2F; more than one record of data. This kind is task consistent, has low
      ///&#x2F; influence to the real time, but needs, dependent to the ring capacity, a lot
      ///&#x2F; of memory. By default the ring capacity is &lt;c>10&lt;/c>, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      ///&#x2F; witch a self defined size.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in faster tasks than the consumer does
      ///&#x2F; and for which it is necessary to guarantee that every data record will be stored,
      ///&#x2F; without a single gap.
      ///&#x2F; Note that this kind uses a lot of memory!
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;/list>
      ///&#x2F; &lt;para>
      ///&#x2F; After the subscription is created successfully, variables could be added with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      ///&#x2F; with the &lt;c>SubscriptionId&lt;/c> just returned in this method.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="kind">
      ///&#x2F; The kind of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;para>&lt;/para>&lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse CreateSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of the given &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This method allows other components, also from remote targets,
      ///&#x2F; to create a subscription which is able to subscribe each PLC variable.
      ///&#x2F; On success it returns a unique &lt;c>SubscriptionId&lt;/c> which is
      ///&#x2F; created internally. The &lt;c>SubscriptionId&lt;/c> has to be exposed to the SDK
      ///&#x2F; user, due to the usage on remote targets. The &lt;c>SubscriptionId&lt;/c> is
      ///&#x2F; the reference to a created subscription at the PLC target and is needed in
      ///&#x2F; each subscription method exclude this and &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each subscription contains at least one buffer which kind depends on the
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      ///&#x2F; tasks which contains the added variables. The buffer are initialized with a
      ///&#x2F; &lt;see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      ///&#x2F; Apart from &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      ///&#x2F; the task. How often the task stores the data to the buffer depends on the task
      ///&#x2F; cycle time and the configured subscription sample interval.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      ///&#x2F; created. Each kind has its own benefits and differs in consistence, performance and
      ///&#x2F; memory usage. The available kinds are listed below:
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;list type="table">
      ///&#x2F; &lt;listheader>
      ///&#x2F; &lt;term>kind&lt;/term>
      ///&#x2F; &lt;description>description&lt;/description>
      ///&#x2F; &lt;/listheader>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; The subscription itself triggers the copy process and will read the data
      ///&#x2F; directly from the source. This could be the fastest way and with no
      ///&#x2F; influence to the real time, to get the current data, but
      ///&#x2F; the task consistency is not guaranteed.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Asynchronous data collection for non critical data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>DoubleBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has low
      ///&#x2F; influence to the real time and is low in memory usage.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Standard way to collect the variable data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>QuadBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has the
      ///&#x2F; fastest access to the current written data, but uses the fourfold memory.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in high speed tasks and for which
      ///&#x2F; it is necessary to guarantee the fastest access to the current written data.
      ///&#x2F; Note that in most cases the &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      ///&#x2F; sufficient.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>RingBuffer&lt;/c> which is able to store
      ///&#x2F; more than one record of data. This kind is task consistent, has low
      ///&#x2F; influence to the real time, but needs, dependent to the ring capacity, a lot
      ///&#x2F; of memory. By default the ring capacity is &lt;c>10&lt;/c>, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      ///&#x2F; witch a self defined size.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in faster tasks than the consumer does
      ///&#x2F; and for which it is necessary to guarantee that every data record will be stored,
      ///&#x2F; without a single gap.
      ///&#x2F; Note that this kind uses a lot of memory!
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;/list>
      ///&#x2F; &lt;para>
      ///&#x2F; After the subscription is created successfully, variables could be added with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      ///&#x2F; with the &lt;c>SubscriptionId&lt;/c> just returned in this method.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="kind">
      ///&#x2F; The kind of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;para>&lt;/para>&lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse> CreateSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateSubscriptionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of the given &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This method allows other components, also from remote targets,
      ///&#x2F; to create a subscription which is able to subscribe each PLC variable.
      ///&#x2F; On success it returns a unique &lt;c>SubscriptionId&lt;/c> which is
      ///&#x2F; created internally. The &lt;c>SubscriptionId&lt;/c> has to be exposed to the SDK
      ///&#x2F; user, due to the usage on remote targets. The &lt;c>SubscriptionId&lt;/c> is
      ///&#x2F; the reference to a created subscription at the PLC target and is needed in
      ///&#x2F; each subscription method exclude this and &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each subscription contains at least one buffer which kind depends on the
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      ///&#x2F; tasks which contains the added variables. The buffer are initialized with a
      ///&#x2F; &lt;see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      ///&#x2F; Apart from &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      ///&#x2F; the task. How often the task stores the data to the buffer depends on the task
      ///&#x2F; cycle time and the configured subscription sample interval.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      ///&#x2F; created. Each kind has its own benefits and differs in consistence, performance and
      ///&#x2F; memory usage. The available kinds are listed below:
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;list type="table">
      ///&#x2F; &lt;listheader>
      ///&#x2F; &lt;term>kind&lt;/term>
      ///&#x2F; &lt;description>description&lt;/description>
      ///&#x2F; &lt;/listheader>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; The subscription itself triggers the copy process and will read the data
      ///&#x2F; directly from the source. This could be the fastest way and with no
      ///&#x2F; influence to the real time, to get the current data, but
      ///&#x2F; the task consistency is not guaranteed.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Asynchronous data collection for non critical data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>DoubleBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has low
      ///&#x2F; influence to the real time and is low in memory usage.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: Standard way to collect the variable data.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>QuadBuffer&lt;/c> which contains the last
      ///&#x2F; written data from the added variables. This kind is task consistent, has the
      ///&#x2F; fastest access to the current written data, but uses the fourfold memory.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in high speed tasks and for which
      ///&#x2F; it is necessary to guarantee the fastest access to the current written data.
      ///&#x2F; Note that in most cases the &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      ///&#x2F; sufficient.
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;item>
      ///&#x2F; &lt;term>
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      ///&#x2F; &lt;/term>
      ///&#x2F; &lt;description>
      ///&#x2F; This subscription uses a &lt;c>RingBuffer&lt;/c> which is able to store
      ///&#x2F; more than one record of data. This kind is task consistent, has low
      ///&#x2F; influence to the real time, but needs, dependent to the ring capacity, a lot
      ///&#x2F; of memory. By default the ring capacity is &lt;c>10&lt;/c>, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      ///&#x2F; witch a self defined size.
      ///&#x2F; &lt;para>
      ///&#x2F; Usage example: For variables which are running in faster tasks than the consumer does
      ///&#x2F; and for which it is necessary to guarantee that every data record will be stored,
      ///&#x2F; without a single gap.
      ///&#x2F; Note that this kind uses a lot of memory!
      ///&#x2F; &lt;/para>&lt;/description>
      ///&#x2F; &lt;/item>
      ///&#x2F; &lt;/list>
      ///&#x2F; &lt;para>
      ///&#x2F; After the subscription is created successfully, variables could be added with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      ///&#x2F; with the &lt;c>SubscriptionId&lt;/c> just returned in this method.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="kind">
      ///&#x2F; The kind of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;para>&lt;/para>&lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse> CreateSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; This method creates a subscription of the kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; Compared to the method &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      ///&#x2F; configure the capacity of the internal used ring buffer.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="recordCount">
      ///&#x2F; The maximum number of storable records.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse CreateRecordingSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateRecordingSubscription(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; This method creates a subscription of the kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; Compared to the method &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      ///&#x2F; configure the capacity of the internal used ring buffer.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="recordCount">
      ///&#x2F; The maximum number of storable records.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse CreateRecordingSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateRecordingSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; This method creates a subscription of the kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; Compared to the method &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      ///&#x2F; configure the capacity of the internal used ring buffer.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="recordCount">
      ///&#x2F; The maximum number of storable records.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse> CreateRecordingSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateRecordingSubscriptionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Creates a subscription of &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; This method creates a subscription of the kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      ///&#x2F; Compared to the method &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      ///&#x2F; configure the capacity of the internal used ring buffer.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="recordCount">
      ///&#x2F; The maximum number of storable records.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; The unique subscription id on success, otherwise 0.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse> CreateRecordingSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateRecordingSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting the given
      ///&#x2F; variable name
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The added variable is stored in a internal container and will be
      ///&#x2F; subscribed after calling &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      ///&#x2F; the subscription has already been subscribed, it is necessary to
      ///&#x2F; call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      ///&#x2F; added variable finally.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; If the same full variable name is added multiple times, the old variable will be
      ///&#x2F; overridden. In case, a variable name is invalid or doesn't exists
      ///&#x2F; a specific error code will be returned &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; on success the code &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; of the added variable will be returned. A variable which doesn't returned with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      ///&#x2F; and won't be subscribed.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A single array element can added with its index in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[index]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; If an array variable is added without a variable specification,
      ///&#x2F; the entire array will be added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; An alternative way to insert variables to the subscription is by using
      ///&#x2F; the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variable is add to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse AddVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddVariable(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting the given
      ///&#x2F; variable name
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The added variable is stored in a internal container and will be
      ///&#x2F; subscribed after calling &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      ///&#x2F; the subscription has already been subscribed, it is necessary to
      ///&#x2F; call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      ///&#x2F; added variable finally.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; If the same full variable name is added multiple times, the old variable will be
      ///&#x2F; overridden. In case, a variable name is invalid or doesn't exists
      ///&#x2F; a specific error code will be returned &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; on success the code &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; of the added variable will be returned. A variable which doesn't returned with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      ///&#x2F; and won't be subscribed.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A single array element can added with its index in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[index]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; If an array variable is added without a variable specification,
      ///&#x2F; the entire array will be added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; An alternative way to insert variables to the subscription is by using
      ///&#x2F; the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variable is add to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse AddVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AddVariable, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting the given
      ///&#x2F; variable name
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The added variable is stored in a internal container and will be
      ///&#x2F; subscribed after calling &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      ///&#x2F; the subscription has already been subscribed, it is necessary to
      ///&#x2F; call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      ///&#x2F; added variable finally.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; If the same full variable name is added multiple times, the old variable will be
      ///&#x2F; overridden. In case, a variable name is invalid or doesn't exists
      ///&#x2F; a specific error code will be returned &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; on success the code &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; of the added variable will be returned. A variable which doesn't returned with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      ///&#x2F; and won't be subscribed.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A single array element can added with its index in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[index]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; If an array variable is added without a variable specification,
      ///&#x2F; the entire array will be added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; An alternative way to insert variables to the subscription is by using
      ///&#x2F; the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variable is add to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse> AddVariableAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddVariableAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting the given
      ///&#x2F; variable name
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The added variable is stored in a internal container and will be
      ///&#x2F; subscribed after calling &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      ///&#x2F; the subscription has already been subscribed, it is necessary to
      ///&#x2F; call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      ///&#x2F; added variable finally.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; If the same full variable name is added multiple times, the old variable will be
      ///&#x2F; overridden. In case, a variable name is invalid or doesn't exists
      ///&#x2F; a specific error code will be returned &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; on success the code &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; of the added variable will be returned. A variable which doesn't returned with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      ///&#x2F; and won't be subscribed.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A single array element can added with its index in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[index]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      ///&#x2F; &lt;code>
      ///&#x2F; ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; If an array variable is added without a variable specification,
      ///&#x2F; the entire array will be added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; An alternative way to insert variables to the subscription is by using
      ///&#x2F; the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variable is add to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse> AddVariableAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AddVariable, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting a range of new variables.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Allows to add a range of variables to the subscription. The returned array of type &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variables are added to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableNames">
      ///&#x2F; An array of full variable names.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns a vector of &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />, &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; on success, in the same order as the variables were added.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse AddVariables(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddVariables(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting a range of new variables.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Allows to add a range of variables to the subscription. The returned array of type &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variables are added to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableNames">
      ///&#x2F; An array of full variable names.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns a vector of &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />, &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; on success, in the same order as the variables were added.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse AddVariables(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AddVariables, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting a range of new variables.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Allows to add a range of variables to the subscription. The returned array of type &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variables are added to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableNames">
      ///&#x2F; An array of full variable names.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns a vector of &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />, &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; on success, in the same order as the variables were added.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse> AddVariablesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddVariablesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Extends the subscription with the given id by inserting a range of new variables.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Allows to add a range of variables to the subscription. The returned array of type &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />,
      ///&#x2F; is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription where the variables are added to.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableNames">
      ///&#x2F; An array of full variable names.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns a vector of &lt;see cref="Arp.Device.Interface.Services.DataAccessError" />, &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      ///&#x2F; on success, in the same order as the variables were added.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse> AddVariablesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AddVariables, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Removes the variable with the specific variable name from the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Removes the variable that compare equal to the given variable name, from the
      ///&#x2F; internal variable list. If the subscription has already been subscribed,
      ///&#x2F; it is necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      ///&#x2F; remove the given variable from the internal created buffer.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable to be removed from the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse RemoveVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RemoveVariable(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Removes the variable with the specific variable name from the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Removes the variable that compare equal to the given variable name, from the
      ///&#x2F; internal variable list. If the subscription has already been subscribed,
      ///&#x2F; it is necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      ///&#x2F; remove the given variable from the internal created buffer.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable to be removed from the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse RemoveVariable(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RemoveVariable, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Removes the variable with the specific variable name from the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Removes the variable that compare equal to the given variable name, from the
      ///&#x2F; internal variable list. If the subscription has already been subscribed,
      ///&#x2F; it is necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      ///&#x2F; remove the given variable from the internal created buffer.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable to be removed from the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse> RemoveVariableAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RemoveVariableAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Removes the variable with the specific variable name from the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Removes the variable that compare equal to the given variable name, from the
      ///&#x2F; internal variable list. If the subscription has already been subscribed,
      ///&#x2F; it is necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      ///&#x2F; remove the given variable from the internal created buffer.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableName">
      ///&#x2F; The full name of the variable to be removed from the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse> RemoveVariableAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RemoveVariable, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Subscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; All previously added variables including in the given subscription will be subscribed. Internally
      ///&#x2F; the variables are separated in the respective tasks, a buffer for each task will be created and
      ///&#x2F; connected to the task executed event. At this point the task will copy the selected variable data
      ///&#x2F; into the task buffer (excluded subscriptions from kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      ///&#x2F; How often the task stores the data to the buffer depends on the task cycle time and the
      ///&#x2F; configured subscription sample rate.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Calling this method on a already subscribed subscription has no effect, even if new
      ///&#x2F; variables have been added or removed. To make variable modification effective, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      ///&#x2F; &lt;c>Unsubscribed&lt;/c>, because &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      ///&#x2F; connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      ///&#x2F; Compare to the first and initial call of this method, this call cost more less time because
      ///&#x2F; the buffer are already created. This also means that variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      ///&#x2F; it is also necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A subscribed subscription can operates in different sample rates (excluded subscriptions from
      ///&#x2F; kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      ///&#x2F; First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      ///&#x2F; the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      ///&#x2F; task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      ///&#x2F; Thats the case if the given sample rate is set to zero,
      ///&#x2F; which means the subscription operates in &lt;c>'real-time'&lt;/c>, the same sample rate the task is operating in.
      ///&#x2F; This is also the fastest possible rate for a subscription.
      ///&#x2F; Note that it's possible that one subscription could contain variables from different tasks, which has the
      ///&#x2F; consequence that the subscription operates in different rates!
      ///&#x2F; If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      ///&#x2F; no matter from which task this variable comes.
      ///&#x2F; Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      ///&#x2F; the given rate will rounded down. E.g.:
      ///&#x2F;
      ///&#x2F; &lt;code>
      ///&#x2F; Task A cycle rate = 10ms
      ///&#x2F; Task B cycle rate = 8ms
      ///&#x2F;
      ///&#x2F; Subscription given rate = 50ms
      ///&#x2F;
      ///&#x2F; Subscription rate for task A = 50ms
      ///&#x2F; Subscription rate for task B = 48ms
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      ///&#x2F; the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      ///&#x2F; But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      ///&#x2F; the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      ///&#x2F; downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      ///&#x2F; or an multiple of them.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse Subscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Subscribe(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Subscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; All previously added variables including in the given subscription will be subscribed. Internally
      ///&#x2F; the variables are separated in the respective tasks, a buffer for each task will be created and
      ///&#x2F; connected to the task executed event. At this point the task will copy the selected variable data
      ///&#x2F; into the task buffer (excluded subscriptions from kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      ///&#x2F; How often the task stores the data to the buffer depends on the task cycle time and the
      ///&#x2F; configured subscription sample rate.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Calling this method on a already subscribed subscription has no effect, even if new
      ///&#x2F; variables have been added or removed. To make variable modification effective, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      ///&#x2F; &lt;c>Unsubscribed&lt;/c>, because &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      ///&#x2F; connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      ///&#x2F; Compare to the first and initial call of this method, this call cost more less time because
      ///&#x2F; the buffer are already created. This also means that variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      ///&#x2F; it is also necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A subscribed subscription can operates in different sample rates (excluded subscriptions from
      ///&#x2F; kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      ///&#x2F; First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      ///&#x2F; the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      ///&#x2F; task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      ///&#x2F; Thats the case if the given sample rate is set to zero,
      ///&#x2F; which means the subscription operates in &lt;c>'real-time'&lt;/c>, the same sample rate the task is operating in.
      ///&#x2F; This is also the fastest possible rate for a subscription.
      ///&#x2F; Note that it's possible that one subscription could contain variables from different tasks, which has the
      ///&#x2F; consequence that the subscription operates in different rates!
      ///&#x2F; If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      ///&#x2F; no matter from which task this variable comes.
      ///&#x2F; Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      ///&#x2F; the given rate will rounded down. E.g.:
      ///&#x2F;
      ///&#x2F; &lt;code>
      ///&#x2F; Task A cycle rate = 10ms
      ///&#x2F; Task B cycle rate = 8ms
      ///&#x2F;
      ///&#x2F; Subscription given rate = 50ms
      ///&#x2F;
      ///&#x2F; Subscription rate for task A = 50ms
      ///&#x2F; Subscription rate for task B = 48ms
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      ///&#x2F; the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      ///&#x2F; But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      ///&#x2F; the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      ///&#x2F; downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      ///&#x2F; or an multiple of them.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse Subscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Subscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Subscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; All previously added variables including in the given subscription will be subscribed. Internally
      ///&#x2F; the variables are separated in the respective tasks, a buffer for each task will be created and
      ///&#x2F; connected to the task executed event. At this point the task will copy the selected variable data
      ///&#x2F; into the task buffer (excluded subscriptions from kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      ///&#x2F; How often the task stores the data to the buffer depends on the task cycle time and the
      ///&#x2F; configured subscription sample rate.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Calling this method on a already subscribed subscription has no effect, even if new
      ///&#x2F; variables have been added or removed. To make variable modification effective, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      ///&#x2F; &lt;c>Unsubscribed&lt;/c>, because &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      ///&#x2F; connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      ///&#x2F; Compare to the first and initial call of this method, this call cost more less time because
      ///&#x2F; the buffer are already created. This also means that variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      ///&#x2F; it is also necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A subscribed subscription can operates in different sample rates (excluded subscriptions from
      ///&#x2F; kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      ///&#x2F; First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      ///&#x2F; the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      ///&#x2F; task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      ///&#x2F; Thats the case if the given sample rate is set to zero,
      ///&#x2F; which means the subscription operates in &lt;c>'real-time'&lt;/c>, the same sample rate the task is operating in.
      ///&#x2F; This is also the fastest possible rate for a subscription.
      ///&#x2F; Note that it's possible that one subscription could contain variables from different tasks, which has the
      ///&#x2F; consequence that the subscription operates in different rates!
      ///&#x2F; If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      ///&#x2F; no matter from which task this variable comes.
      ///&#x2F; Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      ///&#x2F; the given rate will rounded down. E.g.:
      ///&#x2F;
      ///&#x2F; &lt;code>
      ///&#x2F; Task A cycle rate = 10ms
      ///&#x2F; Task B cycle rate = 8ms
      ///&#x2F;
      ///&#x2F; Subscription given rate = 50ms
      ///&#x2F;
      ///&#x2F; Subscription rate for task A = 50ms
      ///&#x2F; Subscription rate for task B = 48ms
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      ///&#x2F; the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      ///&#x2F; But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      ///&#x2F; the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      ///&#x2F; downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      ///&#x2F; or an multiple of them.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse> SubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Subscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; All previously added variables including in the given subscription will be subscribed. Internally
      ///&#x2F; the variables are separated in the respective tasks, a buffer for each task will be created and
      ///&#x2F; connected to the task executed event. At this point the task will copy the selected variable data
      ///&#x2F; into the task buffer (excluded subscriptions from kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      ///&#x2F; How often the task stores the data to the buffer depends on the task cycle time and the
      ///&#x2F; configured subscription sample rate.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Calling this method on a already subscribed subscription has no effect, even if new
      ///&#x2F; variables have been added or removed. To make variable modification effective, use
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      ///&#x2F; &lt;c>Unsubscribed&lt;/c>, because &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      ///&#x2F; connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      ///&#x2F; Compare to the first and initial call of this method, this call cost more less time because
      ///&#x2F; the buffer are already created. This also means that variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      ///&#x2F; it is also necessary to call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; A subscribed subscription can operates in different sample rates (excluded subscriptions from
      ///&#x2F; kind &lt;see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      ///&#x2F; First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      ///&#x2F; the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      ///&#x2F; task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      ///&#x2F; Thats the case if the given sample rate is set to zero,
      ///&#x2F; which means the subscription operates in &lt;c>'real-time'&lt;/c>, the same sample rate the task is operating in.
      ///&#x2F; This is also the fastest possible rate for a subscription.
      ///&#x2F; Note that it's possible that one subscription could contain variables from different tasks, which has the
      ///&#x2F; consequence that the subscription operates in different rates!
      ///&#x2F; If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      ///&#x2F; no matter from which task this variable comes.
      ///&#x2F; Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      ///&#x2F; the given rate will rounded down. E.g.:
      ///&#x2F;
      ///&#x2F; &lt;code>
      ///&#x2F; Task A cycle rate = 10ms
      ///&#x2F; Task B cycle rate = 8ms
      ///&#x2F;
      ///&#x2F; Subscription given rate = 50ms
      ///&#x2F;
      ///&#x2F; Subscription rate for task A = 50ms
      ///&#x2F; Subscription rate for task B = 48ms
      ///&#x2F; &lt;/code>
      ///&#x2F;
      ///&#x2F; Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      ///&#x2F; the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      ///&#x2F; But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      ///&#x2F; the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      ///&#x2F; downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      ///&#x2F; or an multiple of them.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse> SubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Subscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Resubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Resubscribes the subscription, which will trigger a completely rebuild process of
      ///&#x2F; the whole subscription, including previously done variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; It destroys the internal buffer and subscribes the subscription again
      ///&#x2F; (for further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      ///&#x2F; Note that the subscription is not able to collect data from the variables, while the
      ///&#x2F; resubscribe process is in progress.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse Resubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Resubscribe(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Resubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Resubscribes the subscription, which will trigger a completely rebuild process of
      ///&#x2F; the whole subscription, including previously done variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; It destroys the internal buffer and subscribes the subscription again
      ///&#x2F; (for further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      ///&#x2F; Note that the subscription is not able to collect data from the variables, while the
      ///&#x2F; resubscribe process is in progress.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse Resubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Resubscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Resubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Resubscribes the subscription, which will trigger a completely rebuild process of
      ///&#x2F; the whole subscription, including previously done variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; It destroys the internal buffer and subscribes the subscription again
      ///&#x2F; (for further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      ///&#x2F; Note that the subscription is not able to collect data from the variables, while the
      ///&#x2F; resubscribe process is in progress.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse> ResubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ResubscribeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Resubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Resubscribes the subscription, which will trigger a completely rebuild process of
      ///&#x2F; the whole subscription, including previously done variable modification which have been
      ///&#x2F; done after the first call of &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; It destroys the internal buffer and subscribes the subscription again
      ///&#x2F; (for further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      ///&#x2F; Note that the subscription is not able to collect data from the variables, while the
      ///&#x2F; resubscribe process is in progress.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="sampleRate">
      ///&#x2F; The desired sample rate in microseconds.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      ///&#x2F; &lt;seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse> ResubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Resubscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Unsubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Unsubscribes the subscription from all task executed events. The subscription
      ///&#x2F; data are still exist and could be get by the respective read-methods. To
      ///&#x2F; subscribe the subscription again, call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse Unsubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Unsubscribe(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Unsubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Unsubscribes the subscription from all task executed events. The subscription
      ///&#x2F; data are still exist and could be get by the respective read-methods. To
      ///&#x2F; subscribe the subscription again, call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse Unsubscribe(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Unsubscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Unsubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Unsubscribes the subscription from all task executed events. The subscription
      ///&#x2F; data are still exist and could be get by the respective read-methods. To
      ///&#x2F; subscribe the subscription again, call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse> UnsubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UnsubscribeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Unsubscribes the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; Unsubscribes the subscription from all task executed events. The subscription
      ///&#x2F; data are still exist and could be get by the respective read-methods. To
      ///&#x2F; subscribe the subscription again, call &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This method has only an effect if the given subscription is currently subscribed,
      ///&#x2F; otherwise nothing will happen.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse> UnsubscribeAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Unsubscribe, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Deletes the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Deletes the subscription with the given id. After that the id is no longer valid and all data,
      ///&#x2F; containing in the subscription will be removed.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse DeleteSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteSubscription(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Deletes the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Deletes the subscription with the given id. After that the id is no longer valid and all data,
      ///&#x2F; containing in the subscription will be removed.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse DeleteSubscription(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Deletes the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Deletes the subscription with the given id. After that the id is no longer valid and all data,
      ///&#x2F; containing in the subscription will be removed.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse> DeleteSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteSubscriptionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Deletes the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; Deletes the subscription with the given id. After that the id is no longer valid and all data,
      ///&#x2F; containing in the subscription will be removed.
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse> DeleteSubscriptionAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteSubscription, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The subscription service provides several read functions
      ///&#x2F; (&lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      ///&#x2F; return the plain values without any information of type and order.
      ///&#x2F; To assign this plain values to the added variables, this function returns
      ///&#x2F; the currently subscribed variable information in a array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      ///&#x2F; This order and type information wont change, till
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      ///&#x2F; Note that this order does not have to be the same order like the
      ///&#x2F; variables has been added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      ///&#x2F; The provided information contains only information of the added and
      ///&#x2F; currently subscribed variables. It doesn't contain information
      ///&#x2F; of timestamps. Timestamps could be read by the function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      ///&#x2F; information with &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      ///&#x2F; timestamp information.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse GetVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetVariableInfos(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The subscription service provides several read functions
      ///&#x2F; (&lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      ///&#x2F; return the plain values without any information of type and order.
      ///&#x2F; To assign this plain values to the added variables, this function returns
      ///&#x2F; the currently subscribed variable information in a array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      ///&#x2F; This order and type information wont change, till
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      ///&#x2F; Note that this order does not have to be the same order like the
      ///&#x2F; variables has been added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      ///&#x2F; The provided information contains only information of the added and
      ///&#x2F; currently subscribed variables. It doesn't contain information
      ///&#x2F; of timestamps. Timestamps could be read by the function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      ///&#x2F; information with &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      ///&#x2F; timestamp information.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse GetVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetVariableInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The subscription service provides several read functions
      ///&#x2F; (&lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      ///&#x2F; return the plain values without any information of type and order.
      ///&#x2F; To assign this plain values to the added variables, this function returns
      ///&#x2F; the currently subscribed variable information in a array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      ///&#x2F; This order and type information wont change, till
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      ///&#x2F; Note that this order does not have to be the same order like the
      ///&#x2F; variables has been added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      ///&#x2F; The provided information contains only information of the added and
      ///&#x2F; currently subscribed variables. It doesn't contain information
      ///&#x2F; of timestamps. Timestamps could be read by the function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      ///&#x2F; information with &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      ///&#x2F; timestamp information.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse> GetVariableInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetVariableInfosAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; The subscription service provides several read functions
      ///&#x2F; (&lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      ///&#x2F; return the plain values without any information of type and order.
      ///&#x2F; To assign this plain values to the added variables, this function returns
      ///&#x2F; the currently subscribed variable information in a array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      ///&#x2F; This order and type information wont change, till
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      ///&#x2F; Note that this order does not have to be the same order like the
      ///&#x2F; variables has been added to the subscription.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      ///&#x2F; The provided information contains only information of the added and
      ///&#x2F; currently subscribed variables. It doesn't contain information
      ///&#x2F; of timestamps. Timestamps could be read by the function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      ///&#x2F; information with &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      ///&#x2F; timestamp information.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse> GetVariableInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetVariableInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information including information
      ///&#x2F; of timestamps of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables and additionally information about the
      ///&#x2F; timestamps. Note that a subscription could contain multiple
      ///&#x2F; timestamps, related on the number of used tasks from which the
      ///&#x2F; added variables are from. The timestamp is always the first value
      ///&#x2F; followed by all to the task related variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse GetTimeStampedVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTimeStampedVariableInfos(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information including information
      ///&#x2F; of timestamps of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables and additionally information about the
      ///&#x2F; timestamps. Note that a subscription could contain multiple
      ///&#x2F; timestamps, related on the number of used tasks from which the
      ///&#x2F; added variables are from. The timestamp is always the first value
      ///&#x2F; followed by all to the task related variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse GetTimeStampedVariableInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetTimeStampedVariableInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information including information
      ///&#x2F; of timestamps of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables and additionally information about the
      ///&#x2F; timestamps. Note that a subscription could contain multiple
      ///&#x2F; timestamps, related on the number of used tasks from which the
      ///&#x2F; added variables are from. The timestamp is always the first value
      ///&#x2F; followed by all to the task related variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse> GetTimeStampedVariableInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTimeStampedVariableInfosAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information including information
      ///&#x2F; of timestamps of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables and additionally information about the
      ///&#x2F; timestamps. Note that a subscription could contain multiple
      ///&#x2F; timestamps, related on the number of used tasks from which the
      ///&#x2F; added variables are from. The timestamp is always the first value
      ///&#x2F; followed by all to the task related variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="variableInfo">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse> GetTimeStampedVariableInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetTimeStampedVariableInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information as a record of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables, its task relation and additionally
      ///&#x2F; information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The information are provided in an array of array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      ///&#x2F; number of different tasks and the second contains the related variable
      ///&#x2F; information which are related to the variables of this task and
      ///&#x2F; additionally information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[][]
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note: This function is currently not supported in C#!.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="recordInfos">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse GetRecordInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetRecordInfos(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information as a record of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables, its task relation and additionally
      ///&#x2F; information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The information are provided in an array of array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      ///&#x2F; number of different tasks and the second contains the related variable
      ///&#x2F; information which are related to the variables of this task and
      ///&#x2F; additionally information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[][]
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note: This function is currently not supported in C#!.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="recordInfos">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse GetRecordInfos(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetRecordInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information as a record of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables, its task relation and additionally
      ///&#x2F; information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The information are provided in an array of array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      ///&#x2F; number of different tasks and the second contains the related variable
      ///&#x2F; information which are related to the variables of this task and
      ///&#x2F; additionally information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[][]
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note: This function is currently not supported in C#!.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="recordInfos">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse> GetRecordInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetRecordInfosAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Get the subscribed variable information as a record of the subscription.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function relates to the read function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      ///&#x2F; The provided information contains information of the added and
      ///&#x2F; currently subscribed variables, its task relation and additionally
      ///&#x2F; information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The information are provided in an array of array of
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      ///&#x2F; number of different tasks and the second contains the related variable
      ///&#x2F; information which are related to the variables of this task and
      ///&#x2F; additionally information about the task related timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Each containing timestamp has the variable name &lt;c>timestamp&lt;/c> and
      ///&#x2F; the data type &lt;see cref="Arp.Plc.DataType.Int64" /> which is provided in
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; VariableInfo[][]
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; VariableInfo[]
      ///&#x2F; timestamp
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; For further information see &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note: This function is currently not supported in C#!.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="recordInfos">
      ///&#x2F; An array of &lt;see cref="Arp.Device.Interface.Services.VariableInfo" />.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse> GetRecordInfosAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetRecordInfos, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables. The data values are returned
      ///&#x2F; in a static order and doesn't contain any type information. To
      ///&#x2F; figure out which value belongs to the added variable, it is necessary
      ///&#x2F; to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note that this values doesn't contain timestamps! If the timestamp is
      ///&#x2F; needed use the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      ///&#x2F; instead.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values of the given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse ReadValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadValues(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables. The data values are returned
      ///&#x2F; in a static order and doesn't contain any type information. To
      ///&#x2F; figure out which value belongs to the added variable, it is necessary
      ///&#x2F; to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note that this values doesn't contain timestamps! If the timestamp is
      ///&#x2F; needed use the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      ///&#x2F; instead.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values of the given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse ReadValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ReadValues, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables. The data values are returned
      ///&#x2F; in a static order and doesn't contain any type information. To
      ///&#x2F; figure out which value belongs to the added variable, it is necessary
      ///&#x2F; to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note that this values doesn't contain timestamps! If the timestamp is
      ///&#x2F; needed use the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      ///&#x2F; instead.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values of the given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse> ReadValuesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadValuesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables. The data values are returned
      ///&#x2F; in a static order and doesn't contain any type information. To
      ///&#x2F; figure out which value belongs to the added variable, it is necessary
      ///&#x2F; to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Note that this values doesn't contain timestamps! If the timestamp is
      ///&#x2F; needed use the function &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      ///&#x2F; instead.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values of the given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse> ReadValuesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ReadValues, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; timestamp task A
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp task B
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values including the timestamps of the
      ///&#x2F; given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse ReadTimeStampedValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadTimeStampedValues(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; timestamp task A
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp task B
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values including the timestamps of the
      ///&#x2F; given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse ReadTimeStampedValues(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ReadTimeStampedValues, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; timestamp task A
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp task B
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values including the timestamps of the
      ///&#x2F; given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse> ReadTimeStampedValuesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadTimeStampedValuesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[]
      ///&#x2F; timestamp task A
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; timestamp task B
      ///&#x2F; b1
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="values">
      ///&#x2F; Contains the plain values including the timestamps of the
      ///&#x2F; given and subscribed variables.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse> ReadTimeStampedValuesAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ReadTimeStampedValues, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id
      ///&#x2F; separated in task records.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps separated
      ///&#x2F; in task records.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The number of returned value records depends on the count of tasks,
      ///&#x2F; the number of sampled data and the number of the given
      ///&#x2F; &lt;paramref name="count" /> parameter.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The structure how the values are returned is strictly defined:
      ///&#x2F; The first array (records) contains n arrays (task records) and where
      ///&#x2F; n depends on the number of tasks.
      ///&#x2F; The array from the second dimension (task records) contains n arrays
      ///&#x2F; (record), where n depends on the number of collected data, one data
      ///&#x2F; record per task cycle.
      ///&#x2F; The array from the third dimension (record) contains the plain
      ///&#x2F; values, starting with the timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; task A sampled 2 cycles
      ///&#x2F; task B sampled 1 cycles
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[] (records)
      ///&#x2F; object[] (task A records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (record cycle 2)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (task B records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="count">
      ///&#x2F; Number of maximum records to be copied per task. If set to zero, all available records
      ///&#x2F; will be copied.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="records">
      ///&#x2F; Array for the subscribed data records including timestamps.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse ReadRecords(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadRecords(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id
      ///&#x2F; separated in task records.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps separated
      ///&#x2F; in task records.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The number of returned value records depends on the count of tasks,
      ///&#x2F; the number of sampled data and the number of the given
      ///&#x2F; &lt;paramref name="count" /> parameter.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The structure how the values are returned is strictly defined:
      ///&#x2F; The first array (records) contains n arrays (task records) and where
      ///&#x2F; n depends on the number of tasks.
      ///&#x2F; The array from the second dimension (task records) contains n arrays
      ///&#x2F; (record), where n depends on the number of collected data, one data
      ///&#x2F; record per task cycle.
      ///&#x2F; The array from the third dimension (record) contains the plain
      ///&#x2F; values, starting with the timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; task A sampled 2 cycles
      ///&#x2F; task B sampled 1 cycles
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[] (records)
      ///&#x2F; object[] (task A records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (record cycle 2)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (task B records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="count">
      ///&#x2F; Number of maximum records to be copied per task. If set to zero, all available records
      ///&#x2F; will be copied.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="records">
      ///&#x2F; Array for the subscribed data records including timestamps.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse ReadRecords(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ReadRecords, null, options, request);
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id
      ///&#x2F; separated in task records.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps separated
      ///&#x2F; in task records.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The number of returned value records depends on the count of tasks,
      ///&#x2F; the number of sampled data and the number of the given
      ///&#x2F; &lt;paramref name="count" /> parameter.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The structure how the values are returned is strictly defined:
      ///&#x2F; The first array (records) contains n arrays (task records) and where
      ///&#x2F; n depends on the number of tasks.
      ///&#x2F; The array from the second dimension (task records) contains n arrays
      ///&#x2F; (record), where n depends on the number of collected data, one data
      ///&#x2F; record per task cycle.
      ///&#x2F; The array from the third dimension (record) contains the plain
      ///&#x2F; values, starting with the timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; task A sampled 2 cycles
      ///&#x2F; task B sampled 1 cycles
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[] (records)
      ///&#x2F; object[] (task A records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (record cycle 2)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (task B records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="count">
      ///&#x2F; Number of maximum records to be copied per task. If set to zero, all available records
      ///&#x2F; will be copied.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="records">
      ///&#x2F; Array for the subscribed data records including timestamps.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse> ReadRecordsAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReadRecordsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///&#x2F; &lt;summary>
      ///&#x2F; Read the data including timestamps from the subscription with the given id
      ///&#x2F; separated in task records.
      ///&#x2F; &lt;/summary>
      ///&#x2F; &lt;remarks>
      ///&#x2F; &lt;para>
      ///&#x2F; This service function returns the plain data values from
      ///&#x2F; the added and subscribed variables including timestamps separated
      ///&#x2F; in task records.
      ///&#x2F; The data values are returned in a static order and doesn't contain
      ///&#x2F; any type information. To figure out which value belongs to the added
      ///&#x2F; variable, it is necessary to call the related information function
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      ///&#x2F; As long as the subscription doesn't resubscribed with
      ///&#x2F; &lt;see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      ///&#x2F; and both, the read value data and information data, are in a static
      ///&#x2F; order.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The number of returned value records depends on the count of tasks,
      ///&#x2F; the number of sampled data and the number of the given
      ///&#x2F; &lt;paramref name="count" /> parameter.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The structure how the values are returned is strictly defined:
      ///&#x2F; The first array (records) contains n arrays (task records) and where
      ///&#x2F; n depends on the number of tasks.
      ///&#x2F; The array from the second dimension (task records) contains n arrays
      ///&#x2F; (record), where n depends on the number of collected data, one data
      ///&#x2F; record per task cycle.
      ///&#x2F; The array from the third dimension (record) contains the plain
      ///&#x2F; values, starting with the timestamp.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; The read data may contain null values (&lt;see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      ///&#x2F; before the tasks initially have written the data.
      ///&#x2F; &lt;/para>
      ///&#x2F; &lt;para>
      ///&#x2F; Example:
      ///&#x2F; &lt;code>
      ///&#x2F; Added Variable from task A: a1, a2
      ///&#x2F; Added Variable from task B: b1
      ///&#x2F;
      ///&#x2F; task A sampled 2 cycles
      ///&#x2F; task B sampled 1 cycles
      ///&#x2F;
      ///&#x2F; Results in:
      ///&#x2F; object[] (records)
      ///&#x2F; object[] (task A records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (record cycle 2)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; object[] (task B records)
      ///&#x2F; object[] (record cycle 1)
      ///&#x2F; timestamp
      ///&#x2F; a1
      ///&#x2F; a2
      ///&#x2F; &lt;/code>&lt;/para>
      ///&#x2F; &lt;/remarks>
      ///&#x2F; &lt;param name="subscriptionId">
      ///&#x2F; The id of the subscription.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="count">
      ///&#x2F; Number of maximum records to be copied per task. If set to zero, all available records
      ///&#x2F; will be copied.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;param name="records">
      ///&#x2F; Array for the subscribed data records including timestamps.
      ///&#x2F; &lt;/param>
      ///&#x2F; &lt;returns>
      ///&#x2F; Returns &lt;see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      ///&#x2F; &lt;/returns>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse> ReadRecordsAsync(global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ReadRecords, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override ISubscriptionServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new ISubscriptionServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(ISubscriptionServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_CreateSubscription, serviceImpl.CreateSubscription)
          .AddMethod(__Method_CreateRecordingSubscription, serviceImpl.CreateRecordingSubscription)
          .AddMethod(__Method_AddVariable, serviceImpl.AddVariable)
          .AddMethod(__Method_AddVariables, serviceImpl.AddVariables)
          .AddMethod(__Method_RemoveVariable, serviceImpl.RemoveVariable)
          .AddMethod(__Method_Subscribe, serviceImpl.Subscribe)
          .AddMethod(__Method_Resubscribe, serviceImpl.Resubscribe)
          .AddMethod(__Method_Unsubscribe, serviceImpl.Unsubscribe)
          .AddMethod(__Method_DeleteSubscription, serviceImpl.DeleteSubscription)
          .AddMethod(__Method_GetVariableInfos, serviceImpl.GetVariableInfos)
          .AddMethod(__Method_GetTimeStampedVariableInfos, serviceImpl.GetTimeStampedVariableInfos)
          .AddMethod(__Method_GetRecordInfos, serviceImpl.GetRecordInfos)
          .AddMethod(__Method_ReadValues, serviceImpl.ReadValues)
          .AddMethod(__Method_ReadTimeStampedValues, serviceImpl.ReadTimeStampedValues)
          .AddMethod(__Method_ReadRecords, serviceImpl.ReadRecords).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, ISubscriptionServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_CreateSubscription, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateSubscriptionResponse>(serviceImpl.CreateSubscription));
      serviceBinder.AddMethod(__Method_CreateRecordingSubscription, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceCreateRecordingSubscriptionResponse>(serviceImpl.CreateRecordingSubscription));
      serviceBinder.AddMethod(__Method_AddVariable, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariableResponse>(serviceImpl.AddVariable));
      serviceBinder.AddMethod(__Method_AddVariables, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceAddVariablesResponse>(serviceImpl.AddVariables));
      serviceBinder.AddMethod(__Method_RemoveVariable, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceRemoveVariableResponse>(serviceImpl.RemoveVariable));
      serviceBinder.AddMethod(__Method_Subscribe, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceSubscribeResponse>(serviceImpl.Subscribe));
      serviceBinder.AddMethod(__Method_Resubscribe, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceResubscribeResponse>(serviceImpl.Resubscribe));
      serviceBinder.AddMethod(__Method_Unsubscribe, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceUnsubscribeResponse>(serviceImpl.Unsubscribe));
      serviceBinder.AddMethod(__Method_DeleteSubscription, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceDeleteSubscriptionResponse>(serviceImpl.DeleteSubscription));
      serviceBinder.AddMethod(__Method_GetVariableInfos, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetVariableInfosResponse>(serviceImpl.GetVariableInfos));
      serviceBinder.AddMethod(__Method_GetTimeStampedVariableInfos, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetTimeStampedVariableInfosResponse>(serviceImpl.GetTimeStampedVariableInfos));
      serviceBinder.AddMethod(__Method_GetRecordInfos, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceGetRecordInfosResponse>(serviceImpl.GetRecordInfos));
      serviceBinder.AddMethod(__Method_ReadValues, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadValuesResponse>(serviceImpl.ReadValues));
      serviceBinder.AddMethod(__Method_ReadTimeStampedValues, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadTimeStampedValuesResponse>(serviceImpl.ReadTimeStampedValues));
      serviceBinder.AddMethod(__Method_ReadRecords, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsRequest, global::Arp.Plc.Gds.Services.Grpc.ISubscriptionServiceReadRecordsResponse>(serviceImpl.ReadRecords));
    }

  }
}
#endregion
